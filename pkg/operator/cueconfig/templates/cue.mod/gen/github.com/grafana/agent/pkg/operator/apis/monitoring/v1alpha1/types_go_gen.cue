// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/grafana/agent/pkg/operator/apis/monitoring/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	prom_v1 "github.com/prometheus-operator/prometheus-operator/pkg/apis/monitoring/v1"
	"k8s.io/api/core/v1"
)

// GrafanaAgent defines a Grafana Agent deployment.
#GrafanaAgent: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec holds the specification of the desired behavior for the Grafana Agent
	// cluster.
	spec?: #GrafanaAgentSpec @go(Spec)
}

// GrafanaAgentList is a list of GrafanaAgents.
#GrafanaAgentList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)

	// Items is the list of GrafanaAgents.
	items: [...null | #GrafanaAgent] @go(Items,[]*GrafanaAgent)
}

// GrafanaAgentSpec is a specification of the desired behavior of the Grafana
// Agent cluster.
#GrafanaAgentSpec: {
	// LogLevel controls the log level of the generated pods. Defaults to "info" if not set.
	logLevel?: string @go(LogLevel)

	// LogFormat controls the logging format of the generated pods. Defaults to "logfmt" if not set.
	logFormat?: string @go(LogFormat)

	// APIServerConfig allows specifying a host and auth methods to access the
	// Kubernetes API server. If left empty, the Agent will assume that it is
	// running inside of the cluster and will discover API servers automatically
	// and use the pod's CA certificate and bearer token file at
	// /var/run/secrets/kubernetes.io/serviceaccount.
	apiServer?: null | prom_v1.#APIServerConfig @go(APIServerConfig,*prom_v1.APIServerConfig)

	// PodMetadata configures Labels and Annotations which are propagated to
	// created Grafana Agent pods.
	podMetadata?: null | prom_v1.#EmbeddedObjectMetadata @go(PodMetadata,*prom_v1.EmbeddedObjectMetadata)

	// Version of Grafana Agent to be deployed.
	version?: string @go(Version)

	// Paused prevents actions except for deletion to be performed on the
	// underlying managed objects.
	paused?: bool @go(Paused)

	// Image, when specified, overrides the image used to run the Agent. It
	// should be specified along with a tag. Version must still be set to ensure
	// the Grafana Agent Operator knows which version of Grafana Agent is being
	// configured.
	image?: null | string @go(Image,*string)

	// ImagePullSecrets holds an optional list of references to secrets within
	// the same namespace to use for pulling the Grafana Agent image from
	// registries.
	// More info: https://kubernetes.io/docs/user-guide/images#specifying-imagepullsecrets-on-a-pod
	imagePullSecrets?: [...v1.#LocalObjectReference] @go(ImagePullSecrets,[]v1.LocalObjectReference)

	// Storage spec to specify how storage will be used.
	storage?: null | prom_v1.#StorageSpec @go(Storage,*prom_v1.StorageSpec)

	// Volumes allows configuration of additional volumes on the output
	// StatefulSet definition. Volumes specified will be appended to other
	// volumes that are generated as a result of StorageSpec objects.
	volumes?: [...v1.#Volume] @go(Volumes,[]v1.Volume)

	// VolumeMounts allows configuration of additional VolumeMounts on the output
	// StatefulSet definition. VolumEMounts specified will be appended to other
	// VolumeMounts in the Grafana Agent container that are generated as a result
	// of StorageSpec objects.
	volumeMounts?: [...v1.#VolumeMount] @go(VolumeMounts,[]v1.VolumeMount)

	// Resources holds requests and limits for individual pods.
	resources?: v1.#ResourceRequirements @go(Resources)

	// NodeSelector defines which nodes pods should be scheduling on.
	nodeSelector?: {[string]: string} @go(NodeSelector,map[string]string)

	// ServiceAccountName is the name of the ServiceAccount to use for running Grafana Agent pods.
	serviceAccountName?: string @go(ServiceAccountName)

	// Secrets is a list of secrets in the same namespace as the GrafanaAgent
	// object which will be mounted into each running Grafana Agent pod.
	// The secrets are mounted into /etc/grafana-agent/secrets/<secret-name>.
	secrets?: [...string] @go(Secrets,[]string)

	// ConfigMaps is a liset of config maps in the same namespace as the
	// GrafanaAgent object which will be mounted into each running Grafana Agent
	// pod.
	// The secrets are mounted into /etc/grafana-agent/configmaps/<configmap-name>.
	configMaps?: [...string] @go(ConfigMaps,[]string)

	// Affinity, if specified, controls pod scheduling constraints.
	affinity?: null | v1.#Affinity @go(Affinity,*v1.Affinity)

	// Tolerations, if specified, controls the pod's tolerations.
	tolerations?: [...v1.#Toleration] @go(Tolerations,[]v1.Toleration)

	// TopologySpreadConstraints, if specified, controls the pod's topology spread constraints.
	topologySpreadConstraints?: [...v1.#TopologySpreadConstraint] @go(TopologySpreadConstraints,[]v1.TopologySpreadConstraint)

	// SecurityContext holds pod-level security attributes and common container
	// settings. When unspecified, defaults to the default PodSecurityContext.
	securityContext?: null | v1.#PodSecurityContext @go(SecurityContext,*v1.PodSecurityContext)

	// Containers allows injecting additional containers or modifying operator
	// generated containers. This can be used to allow adding an authentication
	// proxy to a Grafana Agent pod or to change the behavior of an
	// operator-generated container. Containers described here modify an operator
	// generated container if they share the same name and modifications are done
	// via a strategic merge patch. The current container names are:
	// `grafana-agent` and `config-reloader`. Overriding containers is entirely
	// outside the scope of what the Grafana Agent team will support and by doing
	// so, you accept that this behavior may break at any time without notice.
	containers?: [...v1.#Container] @go(Containers,[]v1.Container)

	// InitContainers allows adding initContainers to the pod definition. These
	// can be used to, for example, fetch secrets for injection into the Grafana
	// Agent configuration from external sources. Any errors during the execution
	// of an initContainer will lead to a restart of the pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// Using initContainers for any use case other than secret fetching is
	// entirely outside the scope of what the Grafana Agent maintainers will
	// support and by doing so, you accept that this behavior may break at any
	// time without notice.
	initContainers?: [...v1.#Container] @go(InitContainers,[]v1.Container)

	// PriorityClassName is the priority class assigned to pods.
	priorityClassName?: string @go(PriorityClassName)

	// Port name used for the pods and governing service. This defaults to agent-metrics.
	portName?: string @go(PortName)

	// Prometheus controls the Prometheus subsystem of the Agent and settings
	// unique to Prometheus-specific pods that are deployed.
	prometheus?: #PrometheusSubsystemSpec @go(Prometheus)
}

// RemoteWriteSpec defines the remote_write configuration for Prometheus.
#RemoteWriteSpec: {
	// Name of the remote_write queue. Must be unique if specified. The name is
	// used in metrics and logging in order to differentiate queues.
	name?: string @go(Name)

	// URL of the endpoint to send samples to.
	url: string @go(URL)

	// RemoteTimeout is the timeout for requests to the remote_write endpoint.
	remoteTimeout?: string @go(RemoteTimeout)

	// Headers is a set of custom HTTP headers to be sent along with each
	// remote_write request. Be aware that any headers set by Grafana Agent
	// itself can't be overwritten.
	headers?: {[string]: string} @go(Headers,map[string]string)

	// WriteRelabelConfigs holds relabel_configs to relabel samples before they are
	// sent to the remote_write endpoint.
	writeRelabelConfigs?: [...prom_v1.#RelabelConfig] @go(WriteRelabelConfigs,[]prom_v1.RelabelConfig)

	// BasicAuth for the URL.
	basicAuth?: null | prom_v1.#BasicAuth @go(BasicAuth,*prom_v1.BasicAuth)

	// BearerToken used for remote_write.
	bearerToken?: string @go(BearerToken)

	// BearerTokenFile used to read bearer token.
	bearerTokenFile?: string @go(BearerTokenFile)

	// SigV4 configures SigV4-based authentication to the remote_write endpoint.
	// Will be used if SigV4 is defined, even with an empty object.
	sigv4?: null | #SigV4Config @go(SigV4,*SigV4Config)

	// TLSConfig to use for remote_write.
	tlsConfig?: null | prom_v1.#TLSConfig @go(TLSConfig,*prom_v1.TLSConfig)

	// ProxyURL to proxy requests through. Optional.
	proxyUrl?: string @go(ProxyURL)

	// QueueConfig allows tuning of the remote_write queue parameters.
	queueConfig?: null | #QueueConfig @go(QueueConfig,*QueueConfig)

	// MetadataConfig configures the sending of series metadata to remote storage.
	metadataConfig?: null | #MetadataConfig @go(MetadataConfig,*MetadataConfig)
}

// SigV4Config specifies configuration to perform SigV4 authentication.
#SigV4Config: {
	// Region of the AWS endpoint. If blank, the region from the default
	// credentials chain is used.
	region?: string @go(Region)

	// AccessKey holds the secret of the AWS API access key to use for signing.
	// If not provided, The environment variable AWS_ACCESS_KEY_ID is used.
	accessKey?: null | v1.#SecretKeySelector @go(AccessKey,*v1.SecretKeySelector)

	// SecretKey of the AWS API to use for signing. If blank, the environment
	// variable AWS_SECRET_ACCESS_KEY is used.
	secretKey?: null | v1.#SecretKeySelector @go(SecretKey,*v1.SecretKeySelector)

	// Profile is the named AWS profile to use for authentication.
	profile?: string @go(Profile)

	// RoleARN is the AWS Role ARN to use for authentication, as an alternative
	// for using the AWS API keys.
	roleARN?: string @go(RoleARN)
}

// QueueConfig allows the tuning of remote_write queue_config parameters.
#QueueConfig: {
	// Capacity is the number of samples to buffer per shard before we start dropping them.
	capacity?: int @go(Capacity)

	// MinShards is the minimum number of shards, i.e. amount of concurrency.
	minShards?: int @go(MinShards)

	// MaxShards is the maximum number of shards, i.e. amount of concurrency.
	maxShards?: int @go(MaxShards)

	// MaxSamplesPerSend is the maximum number of samples per send.
	maxSamplesPerSend?: int @go(MaxSamplesPerSend)

	// BatchSendDeadline is the maximum time a sample will wait in buffer.
	batchSendDeadline?: string @go(BatchSendDeadline)

	// MaxRetries is the maximum number of times to retry a batch on recoverable errors.
	maxRetries?: int @go(MaxRetries)

	// MinBackoff is the initial retry delay. Gets doubled for every retry.
	minBackoff?: string @go(MinBackoff)

	// MaxBackoff is the maximum retry delay.
	maxBackoff?: string @go(MaxBackoff)

	// RetryOnRateLimit retries requests when encountering rate limits.
	retryOnRateLimit?: bool @go(RetryOnRateLimit)
}

// MetadataConfig configures the sending of series metadata to remote storage.
#MetadataConfig: {
	// Send enables metric metadata to be sent to remote storage.
	send?: bool @go(Send)

	// SendInterval controls how frequently metric metadata is sent to remote storage.
	sendInterval?: string @go(SendInterval)
}

// PrometheusSubsystemSpec defines global settings to apply across the
// Prometheus subsystem.
#PrometheusSubsystemSpec: {
	// RemoteWrite controls default remote_write settings for all instances. If
	// an instance does not provide its own remoteWrite settings, these will be
	// used instead.
	remoteWrite?: [...#RemoteWriteSpec] @go(RemoteWrite,[]RemoteWriteSpec)

	// Replicas of each shard to deploy for metrics pods. Number of replicas
	// multiplied by the number of shards is the total number of pods created.
	replicas?: null | int32 @go(Replicas,*int32)

	// Shards to distribute targets onto. Number of replicas multiplied by the
	// number of shards is the total number of pods created. Note that scaling
	// down shards will not reshard data onto remaining instances, it must be
	// manually moved. Increasing shards will not reshard data either but it will
	// continue to be available from the same instances. Sharding is performed on
	// the content of the __address__ target meta-label.
	shards?: null | int32 @go(Shards,*int32)

	// ReplicaExternalLabelName is the name of the Prometheus external label used
	// to denote replica name. Defaults to __replica__. External label will _not_
	// be added when value is set to the empty string.
	replicaExternalLabelName?: null | string @go(ReplicaExternalLabelName,*string)

	// PrometheusExternalLabelName is the name of the external label used to
	// denote Grafana Agent cluster. Defaults to "cluster." External label will
	// _not_ be added when value is set to the empty string.
	prometheusExternalLabelName?: null | string @go(PrometheusExternalLabelName,*string)

	// ScrapeInterval is the time between consecutive scrapes.
	scrapeInterval?: string @go(ScrapeInterval)

	// ScrapeTimeout is the time to wait for a target to respond before marking a
	// scrape as failed.
	scrapeTimeout?: string @go(ScrapeTimeout)

	// ExternalLabels are labels to add to any time series when sending data over
	// remote_write.
	externalLabels?: {[string]: string} @go(ExternalLabels,map[string]string)

	// ArbitraryFSAccessThroughSMs configures whether configuration based on a
	// ServiceMonitor can access arbitrary files on the file system of the
	// Grafana Agent container e.g. bearer token files.
	arbitraryFSAccessThroughSMs?: prom_v1.#ArbitraryFSAccessThroughSMsConfig @go(ArbitraryFSAccessThroughSMs)

	// OverrideHonorLabels, if true, overrides all configured honor_labels read
	// from ServiceMonitor or PodMonitor to false.
	overrideHonorLabels?: bool @go(OverrideHonorLabels)

	// OverrideHonorTimestamps allows to globally enforce honoring timestamps in all scrape configs.
	overrideHonorTimestamps?: bool @go(OverrideHonorTimestamps)

	// IgnoreNamespaceSelectors, if true, will ignore NamespaceSelector settings
	// from the PodMonitor and ServiceMonitor configs, and they will only
	// discover endpoints within their current namespace.
	ignoreNamespaceSelectors?: bool @go(IgnoreNamespaceSelectors)

	// EnforcedNamepsaceLabel enforces adding a namespace label of origin for
	// each metric that is user-created. The label value will always be the
	// namespace of the object that is being created.
	enforcedNamespaceLabel?: string @go(EnforcedNamepsaceLabel)

	// EnforcedSampleLimit defines global limit on the number of scraped samples
	// that will be accepted. This overrides any SampleLimit set per
	// ServiceMonitor and/or PodMonitor. It is meant to be used by admins to
	// enforce the SampleLimit to keep the overall number of samples and series
	// under the desired limit. Note that if a SampleLimit from a ServiceMonitor
	// or PodMonitor is lower, that value will be used instead.
	enforcedSampleLimit?: null | uint64 @go(EnforcedSampleLimit,*uint64)

	// EnforcedTargetLimit defines a global limit on the number of scraped
	// targets. This overrides any TargetLimit set per ServiceMonitor and/or
	// PodMonitor. It is meant to be used by admins to enforce the TargetLimit to
	// keep the overall number of targets under the desired limit. Note that if a
	// TargetLimit from a ServiceMonitor or PodMonitor is higher, that value will
	// be used instead.
	enforcedTargetLimit?: null | uint64 @go(EnforcedTargetLimit,*uint64)

	// InstanceSelector determines which PrometheusInstances should be selected
	// for running. Each instance runs its own set of Prometheus components,
	// including service discovery, scraping, and remote_write.
	instanceSelector?: null | metav1.#LabelSelector @go(InstanceSelector,*metav1.LabelSelector)

	// InstanceNamespaceSelector are the set of labels to determine which
	// namespaces to watch for PrometheusInstances. If not provided, only checks own namespace.
	instanceNamespaceSelector?: null | metav1.#LabelSelector @go(InstanceNamespaceSelector,*metav1.LabelSelector)
}

// PrometheusInstance controls an individual Prometheus instance within a
// Grafana Agent deployment.
#PrometheusInstance: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta)

	// Spec holds the specification of the desired behavior for the Prometheus
	// instance.
	spec?: #PrometheusInstanceSpec @go(Spec)
}

// PrometheusInstanceSpec controls how an individual instance will be used to discover PodMonitors.
#PrometheusInstanceSpec: {
	// WALTruncateFrequency specifies how frequently the WAL truncation process
	// should run. Higher values causes the WAL to increase and for old series to
	// stay in the WAL for longer, but reduces the chances of data loss when
	// remote_write is failing for longer than the given frequency.
	walTruncateFrequency?: string @go(WALTruncateFrequency)

	// MinWALTime is the minimum amount of time series and samples may exist in
	// the WAL before being considered for deletion.
	minWALTime?: string @go(MinWALTime)

	// MaxWALTime is the maximum amount of time series and asmples may exist in
	// the WAL before being forcibly deleted.
	maxWALTime?: string @go(MaxWALTime)

	// RemoteFlushDeadline is the deadline for flushing data when an instance
	// shuts down.
	remoteFlushDeadline?: string @go(RemoteFlushDeadline)

	// WriteStaleOnShutdown writes staleness markers on shutdown for all series.
	writeStaleOnShutdown?: null | bool @go(WriteStaleOnShutdown,*bool)

	// ServiceMonitorSelector determines which ServiceMonitors should be selected
	// for target discovery.
	serviceMonitorSelector?: null | metav1.#LabelSelector @go(ServiceMonitorSelector,*metav1.LabelSelector)

	// ServiceMonitorNamespaceSelector are the set of labels to determine which
	// namespaces to watch for ServiceMonitor discovery. If nil, only checks own
	// namespace.
	serviceMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(ServiceMonitorNamespaceSelector,*metav1.LabelSelector)

	// PodMonitorSelector determines which PodMonitors should be selected for target
	// discovery. Experimental.
	podMonitorSelector?: null | metav1.#LabelSelector @go(PodMonitorSelector,*metav1.LabelSelector)

	// PodMonitorNamespaceSelector are the set of labels to determine which
	// namespaces to watch for PodMonitor discovery. If nil, only checks own
	// namespace.
	podMonitorNamespaceSelector?: null | metav1.#LabelSelector @go(PodMonitorNamespaceSelector,*metav1.LabelSelector)

	// ProbeSelector determines which Probes should be selected for target
	// discovery.
	probeSelector?: null | metav1.#LabelSelector @go(ProbeSelector,*metav1.LabelSelector)

	// ProbeNamespaceSelector are the set of labels to determine which namespaces
	// to watch for Probe discovery. If nil, only checks own namespace.
	probeNamespaceSelector?: null | metav1.#LabelSelector @go(ProbeNamespaceSelector,*metav1.LabelSelector)

	// RemoteWrite controls remote_write settings for this instance.
	remoteWrite?: [...#RemoteWriteSpec] @go(RemoteWrite,[]RemoteWriteSpec)

	// AdditionalScrapeConfigs allows specifying a key of a Secret containing
	// additional Grafana Agent Prometheus scrape configurations. SCrape
	// configurations specified are appended to the configurations generated by
	// the Grafana Agent Operator. Job configurations specified must have the
	// form as specified in the official Prometheus documentation:
	// https://prometheus.io/docs/prometheus/latest/configuration/configuration/#scrape_config.
	// As scrape configs are appended, the user is responsible to make sure it is
	// valid. Note that using this feature may expose the possibility to break
	// upgrades of Grafana Agent. It is advised to review both Grafana Agent and
	// Prometheus release notes to ensure that no incompatible scrape configs are
	// going to break Grafana Agent after the upgrade.
	additionalScrapeConfigs?: null | v1.#SecretKeySelector @go(AdditionalScrapeConfigs,*v1.SecretKeySelector)
}

// PrometheusInstanceList is a list of PrometheusInsatnce.
#PrometheusInstanceList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta)

	// Items is the list of PrometheusInstance.
	items: [...null | #PrometheusInstance] @go(Items,[]*PrometheusInstance)
}
